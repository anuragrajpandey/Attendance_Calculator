<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Attendance — Minimal + Roasts</title>
<style>
  :root{
    --bg:#ffffff;
    --card:#ffffff;
    --muted:#6b7280;
    --text:#0b1220;
    --accent:#0ea5e9;
    --good:#10b981;
    --bad:#ef4444;
    --radius:12px;
    --hit:48px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:var(--bg); color:var(--text); -webkit-text-size-adjust:100%;}
  body{display:flex;align-items:flex-start;justify-content:center;padding:14px 12px;gap:12px;}

  .wrap{width:100%;max-width:980px;background:var(--card);border-radius:14px;padding:12px;box-shadow:0 8px 24px rgba(2,6,23,0.06); border:1px solid rgba(2,6,23,0.04); display:flex;flex-direction:column;gap:12px}
  .head{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .title{font-weight:800;font-size:18px}
  .subtitle{font-size:12px;color:var(--muted)}
  .targets{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .target{padding:10px 12px;border-radius:999px;border:1px solid rgba(2,6,23,0.06);background:transparent;font-weight:800;font-size:14px;min-height:var(--hit); display:inline-flex;align-items:center;justify-content:center; cursor:pointer;}
  .target.active{background:var(--accent);color:white;border:0; box-shadow:0 8px 20px rgba(14,165,233,0.12)}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  .label{font-size:13px;color:var(--muted);margin-bottom:6px}
  .input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(2,6,23,0.06);font-size:16px;background:transparent;-webkit-appearance:none;appearance:none;}
  .row{display:flex;gap:8px}
  .btn{flex:1;padding:12px;border-radius:12px;border:0;font-weight:900;font-size:15px;cursor:pointer;min-height:var(--hit)}
  .btn.primary{background:var(--accent);color:#fff}
  .btn.ghost{background:transparent;border:1px solid rgba(2,6,23,0.06);color:var(--muted)}
  .display{padding:12px;border-radius:12px;background:rgba(2,6,23,0.02);display:flex;flex-direction:column;gap:12px}
  .top{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .percent{font-weight:900;font-size:32px}
  .status{padding:6px 10px;border-radius:999px;font-weight:800;font-size:13px}
  .status.ok{background:rgba(16,185,129,0.12);color:var(--good)}
  .status.low{background:rgba(239,68,68,0.12);color:var(--bad)}
  .muted{color:var(--muted);font-size:13px}
  .panel-row{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .bunk{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:rgba(2,6,23,0.02);font-weight:800}
  .message{padding:10px;border-radius:10px;background:rgba(14,165,233,0.04);font-weight:700;text-align:center}

  /* roast popup */
  .roast{
    position:fixed; left:50%; top:12%; transform:translateX(-50%); min-width:320px; max-width:820px; padding:14px 16px;
    border-radius:12px; background:#111; color:#ffdede; font-weight:900; z-index:3000; display:none; box-shadow:0 20px 70px rgba(0,0,0,0.5);
  }
  .roast .txt{font-size:16px;line-height:1.2}
  .roast .close{margin-top:10px;padding:8px 10px;border-radius:10px;border:0;background:#ff3b30;color:white;cursor:pointer;font-weight:800}

  .toggle-roast{padding:8px 10px;border-radius:10px;border:1px solid rgba(2,6,23,0.06);background:transparent;font-weight:700;cursor:pointer}
  @media(min-width:760px){ .wrap{flex-direction:row} .left{width:360px;flex-shrink:0} .main{flex:1} .grid{grid-template-columns:1fr 1fr; gap:10px} .targets{flex-direction:column} }
</style>
</head>
<body>
  <main class="wrap" role="application" aria-label="Attendance with roasts">
    <div class="head">
      <div>
        <div class="title">Attendance</div>
        <div class="subtitle">Minimal • white theme</div>
      </div>
      <div>
        <button id="toggleRoasts" class="toggle-roast" aria-pressed="true">Roasts: ON</button>
      </div>
    </div>

    <section class="left" style="display:flex;flex-direction:column;gap:10px">
      <div class="muted" style="font-weight:700">Targets</div>
      <div class="targets" id="targets">
        <button class="target" data-val="75" aria-pressed="false">75%</button>
        <button class="target" data-val="80" aria-pressed="false">80%</button>
        <button class="target" data-val="85" aria-pressed="false">85%</button>
        <button class="target" data-val="90" aria-pressed="false">90%</button>
      </div>

      <div style="margin-top:4px">
        <div class="label">Total</div>
        <input id="total" class="input" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="60" />
      </div>

      <div>
        <div class="label">Attended</div>
        <input id="attended" class="input" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="45" />
      </div>

      <div class="row" style="margin-top:6px">
        <button id="present" class="btn primary" aria-label="Mark present">+ Present</button>
        <button id="absent" class="btn ghost" aria-label="Mark absent">+ Absent</button>
      </div>

      <div style="display:flex;gap:8px;margin-top:6px">
        <input id="upcoming" class="input" type="number" inputmode="numeric" placeholder="Upcoming" />
        <input id="willAttend" class="input" type="number" inputmode="numeric" placeholder="Will attend" />
      </div>

      <div class="row" style="margin-top:6px">
        <button id="apply" class="btn ghost">Apply</button>
        <button id="reset" class="btn ghost">Reset</button>
      </div>
    </section>

    <section class="main" style="display:flex;flex-direction:column;gap:10px">
      <div class="display" aria-live="polite">
        <div class="top">
          <div>
            <div class="percent" id="percent">0.00%</div>
            <div class="muted" id="sub">Current</div>
          </div>
          <div id="statusWrap"><span class="status">—</span></div>
        </div>

        <div class="panel-row" style="margin-top:6px">
          <div class="panel-small">
            <div class="muted">Projected</div>
            <div id="proj" style="font-weight:800">0 / 0 — 0.00%</div>
          </div>
          <div class="panel-small">
            <div class="muted">Needed</div>
            <div id="needed" style="font-weight:800">—</div>
          </div>
        </div>

        <div class="bunk" style="margin-top:8px">
          <div class="muted" id="bunkLabel">You can bunk</div>
          <div id="bunkCount" style="font-weight:800">—</div>
        </div>

        <div class="message" id="message" style="margin-top:8px">—</div>
      </div>

      <footer>
        <div class="muted">Simple</div>
        <div class="muted" id="currentTarget">75%</div>
      </footer>
    </section>
  </main>

  <!-- roast popup -->
  <div id="roast" class="roast" role="alert" aria-hidden="true">
    <div class="txt" id="roastText">You messed up.</div>
    <button id="roastClose" class="close">Close</button>
  </div>

<script>
/* Minimal attendance app + 500 roasts (generated via templates, lazy & efficient)
   - White theme only
   - Roasts: show on invalid input + random periodic pop-ups + chance on button clicks
   - Toggle to enable/disable random/pop-up roasts
   - 500 unique messages are generated by combining templates (no huge literal array)
*/

// helpers
const $ = id => document.getElementById(id);
const totalEl = $('total'), attendedEl = $('attended'), upcomingEl = $('upcoming'), willAttendEl = $('willAttend');
const presentBtn = $('present'), absentBtn = $('absent'), applyBtn = $('apply'), resetBtn = $('reset');
const percentEl = $('percent'), statusWrap = $('statusWrap'), projEl = $('proj'), neededEl = $('needed');
const bunkLabel = $('bunkLabel'), bunkCount = $('bunkCount'), messageEl = $('message'), currentTargetEl = $('currentTarget');
const targets = Array.from(document.querySelectorAll('.target'));
const roastBox = $('roast'), roastText = $('roastText'), roastClose = $('roastClose');
const toggleRoasts = $('toggleRoasts');

const KEY = 'att_roast_v1';

// minimal safe number parsing
function toInt(v){ const n = parseInt(String(v).replace(/[^\d-]/g,''),10); return isNaN(n) ? 0 : Math.max(0,n); }
function pct(att, tot){ return tot <= 0 ? 0 : (att / tot) * 100; }
function classesNeeded(att, tot, targetPct){
  const t = targetPct/100;
  if(pct(att,tot) >= targetPct) return 0;
  if(t >= 1) return Infinity;
  const numerator = t * tot - att;
  const denom = 1 - t;
  return Math.max(0, Math.ceil(numerator / denom));
}
function maxBunk(att, tot, targetPct){
  const t = targetPct/100;
  if(t === 0) return Infinity;
  if(pct(att,tot) < targetPct) return 0;
  const raw = (att - t*tot)/t;
  return Math.max(0, Math.floor(raw));
}

// target helpers
function setTarget(v){
  targets.forEach(t => {
    const active = Number(t.dataset.val) === Number(v);
    t.classList.toggle('active', active);
    t.setAttribute('aria-pressed', active?'true':'false');
  });
  currentTargetEl.textContent = Number(v) + '%';
  update(true);
}
function getTarget(){ const a = targets.find(t => t.classList.contains('active')); return a ? Number(a.dataset.val) : 75; }
targets.forEach(t => t.addEventListener('click', ()=> setTarget(t.dataset.val)));

// persistence
function saveState(){
  try{
    const s = { total: toInt(totalEl.value), attended: toInt(attendedEl.value), upcoming: toInt(upcomingEl.value), willAttend: toInt(willAttendEl.value), target: getTarget(), roastsOn: roastsEnabled };
    localStorage.setItem(KEY, JSON.stringify(s));
  }catch(e){}
}
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(KEY) || '{}');
    if(typeof s.total === 'number') totalEl.value = s.total;
    if(typeof s.attended === 'number') attendedEl.value = s.attended;
    if(typeof s.upcoming === 'number') upcomingEl.value = s.upcoming;
    if(typeof s.willAttend === 'number') willAttendEl.value = s.willAttend;
    if(typeof s.target === 'number') setTarget(s.target);
    if(typeof s.roastsOn === 'boolean') setRoastsEnabled(s.roastsOn);
  }catch(e){}
}

// --- ROAST GENERATOR (500 unique-ish, built from templates) ---
// We'll construct 500 messages by combining starts/middles/ends and adding small variants.
// This avoids a monstrous literal array while producing many distinct outputs.
const roastStarts = [
  "Why the hell are you", "Seriously, why are you", "Who told you it's okay to",
  "You absolute", "You're such a", "Stop being a", "Are you actually", "What the fuck, you're"
];
const roastAdjs = [
  "clown", "numpty", "idiot", "buffoon", "dolt", "muppet", "miserable excuse", "trainwreck"
];
const roastVerbs = [
  "typing nonsense", "trying to cheat the system", "entering absurd numbers", "messing with the inputs",
  "acting like a fool", "doing dumb shit", "attempting a hack that won't work"
];
const roastEndings = [
  "— it won't help.", "— stop it.", "— nobody's impressed.", "— the system rejects that.", "— you're wasting time.",
  "— that's beyond dumb.", "— grow up and fix it."
];

// random helper
function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// generate N distinct roasts lazily into pool
let ROAST_POOL = null;
function buildRoastPool(n){
  if(ROAST_POOL && ROAST_POOL.length >= n) return ROAST_POOL;
  ROAST_POOL = [];
  const combos = new Set();
  let i = 0;
  // Create variants until we reach n or hit reasonable attempts
  while(ROAST_POOL.length < n && i < n*10){
    const style = Math.random() < 0.4 ? 0 : 1;
    let msg = "";
    if(style === 0){
      // "Why the hell are you typing nonsense — it won't help."
      msg = `${rand(roastStarts)} ${rand(roastVerbs)} ${rand(roastEndings)}`;
    } else {
      // "You absolute clown — stop it."
      msg = `${rand(roastStarts).replace(/(Why the hell are you|Seriously, why are you|Are you actually|What the fuck, you're)/,'You') } ${rand(roastAdjs)} ${rand(roastEndings)}`;
      // try to clean duplicate phrasing
      msg = msg.replace(/\s+/g,' ').trim();
    }
    // add some punctuation variants or short jab
    if(Math.random() < 0.25) msg = msg.replace(/\.$/, '') + (Math.random()<0.5 ? '!' : ' — really.');
    if(!combos.has(msg) && msg.length > 8){
      combos.add(msg);
      ROAST_POOL.push(msg);
    }
    i++;
  }
  // If still short, fill simpler templates
  while(ROAST_POOL.length < n){
    ROAST_POOL.push(`You're an idiot — stop it. (${ROAST_POOL.length+1})`);
  }
  return ROAST_POOL;
}

// pick a roast (ensures pool exists)
function pickRoast(){
  buildRoastPool(500);
  return ROAST_POOL[Math.floor(Math.random()*ROAST_POOL.length)];
}

// --- roast popup control & behavior ---
let roastsEnabled = true;
function setRoastsEnabled(flag){
  roastsEnabled = !!flag;
  toggleRoasts.textContent = 'Roasts: ' + (roastsEnabled ? 'ON' : 'OFF');
  toggleRoasts.setAttribute('aria-pressed', roastsEnabled ? 'true' : 'false');
  saveState();
}
toggleRoasts.addEventListener('click', ()=> setRoastsEnabled(!roastsEnabled));

// show roast safely (throttled)
let roastTimeout = null, roastVisibleUntil = 0;
function showRoast(msg){
  if(!roastsEnabled) return;
  const now = Date.now();
  // throttle: don't show if a roast was shown within last 4s
  if(now < roastVisibleUntil) return;
  roastVisibleUntil = now + 4500;
  roastText.textContent = msg || pickRoast();
  roastBox.style.display = 'block';
  roastBox.setAttribute('aria-hidden','false');
  if(roastTimeout) clearTimeout(roastTimeout);
  roastTimeout = setTimeout(()=>{ roastBox.style.display = 'none'; roastBox.setAttribute('aria-hidden','true'); }, 4200);
}
$('roastClose').addEventListener('click', ()=>{ roastBox.style.display = 'none'; roastBox.setAttribute('aria-hidden','true'); });

// random periodic roast popups (only when enabled)
let periodicRoastTimer = null;
function schedulePeriodicRoast(){
  if(periodicRoastTimer) clearTimeout(periodicRoastTimer);
  if(!roastsEnabled) return;
  // random time between 30s and 90s
  const t = 30000 + Math.floor(Math.random()*60000);
  periodicRoastTimer = setTimeout(()=>{
    // show only if not in mid-input (simple heuristic)
    const active = document.activeElement;
    if(active && ['INPUT','TEXTAREA'].includes(active.tagName)) {
      // small chance to still roast during typing
      if(Math.random() < 0.25) showRoast();
    } else {
      showRoast();
    }
    schedulePeriodicRoast();
  }, t);
}
toggleRoasts.addEventListener('click', ()=> {
  if(roastsEnabled) schedulePeriodicRoast();
  else {
    if(periodicRoastTimer) clearTimeout(periodicRoastTimer);
  }
});

// previous valid values for reverts
let prevAttended = toInt(attendedEl.value);
let prevWillAttend = toInt(willAttendEl.value);

// Save/load state
loadState();

// minimal update function
let lastState = {};
function update(force){
  const total = toInt(totalEl.value);
  let attended = toInt(attendedEl.value);
  const upcoming = toInt(upcomingEl.value);
  let willAttend = toInt(willAttendEl.value);
  const target = getTarget();

  // Revert typed invalids
  if(attended > total){
    attendedEl.value = prevAttended;
    attended = prevAttended;
    // roast when they try to exceed total
    showRoast(pickRoast());
  } else prevAttended = attended;

  if(willAttend > upcoming){
    willAttendEl.value = prevWillAttend;
    willAttend = prevWillAttend;
    showRoast(pickRoast());
  } else prevWillAttend = willAttend;

  const safeAtt = Math.min(attended, total);
  const curPct = +(pct(safeAtt,total).toFixed(2));
  const state = { total, safeAtt, upcoming, willAttend, curPct, target };
  if(!force && JSON.stringify(state) === JSON.stringify(lastState)) return;
  lastState = state;

  percentEl.textContent = curPct.toFixed(2) + '%';

  if(total === 0) statusWrap.innerHTML = `<span class="status">—</span>`;
  else if(curPct >= target) statusWrap.innerHTML = `<span class="status ok">ON</span>`;
  else statusWrap.innerHTML = `<span class="status low">LOW</span>`;

  const pTot = total + upcoming;
  const pAtt = safeAtt + willAttend;
  projEl.textContent = `${pAtt} / ${pTot} — ${ (pTot===0) ? '0.00%' : pct(pAtt,pTot).toFixed(2)+'%' }`;

  const needed = classesNeeded(attended, total, target);
  neededEl.textContent = needed === Infinity ? 'Impossible' : (needed + (needed===1 ? ' class' : ' classes'));

  if(total === 0 && attended === 0){
    bunkLabel.textContent = 'You can bunk'; bunkCount.textContent = '—'; messageEl.textContent='Enter values';
  } else if(curPct >= target){
    const bunk = maxBunk(attended, total, target);
    bunkLabel.textContent = 'You can bunk';
    bunkCount.textContent = (bunk === Infinity) ? 'Many' : (bunk + (bunk===1 ? ' class' : ' classes'));
    messageEl.textContent = bunk > 0 ? `You can skip ${bunk} and still meet ${target}%.` : 'On track — keep it up.';
  } else {
    const needCount = needed === Infinity ? 'Impossible' : (needed + (needed===1 ? ' class' : ' classes'));
    bunkLabel.textContent = 'You need'; bunkCount.textContent = needCount; messageEl.textContent = 'Below target — attend more.';
  }

  saveState();
}

// input protections wiring & roast triggers
attendedEl.addEventListener('focus', ()=> prevAttended = toInt(attendedEl.value));
attendedEl.addEventListener('input', ()=>{
  const entered = toInt(attendedEl.value), total = toInt(totalEl.value);
  if(entered > total){
    attendedEl.value = prevAttended;
    showRoast(pickRoast());
  } else { prevAttended = entered; update(); }
});

willAttendEl.addEventListener('focus', ()=> prevWillAttend = toInt(willAttendEl.value));
willAttendEl.addEventListener('input', ()=>{
  const entered = toInt(willAttendEl.value), upcoming = toInt(upcomingEl.value);
  if(entered > upcoming){
    willAttendEl.value = prevWillAttend;
    showRoast(pickRoast());
  } else { prevWillAttend = entered; update(); }
});

totalEl.addEventListener('input', ()=>{
  const total = toInt(totalEl.value), attended = toInt(attendedEl.value);
  if(attended > total){
    attendedEl.value = total;
    prevAttended = total;
    showRoast(pickRoast());
  }
  update();
});
upcomingEl.addEventListener('input', update);

// button behaviors — small chance to roast on clicks (15%)
function maybeRoastOnClick(){ if(roastsEnabled && Math.random() < 0.15) showRoast(pickRoast()); }

presentBtn.addEventListener('click', ()=>{
  totalEl.value = toInt(totalEl.value) + 1;
  attendedEl.value = toInt(attendedEl.value) + 1;
  prevAttended = toInt(attendedEl.value);
  update();
  maybeRoastOnClick();
});
absentBtn.addEventListener('click', ()=>{
  totalEl.value = toInt(totalEl.value) + 1;
  update();
  maybeRoastOnClick();
});
applyBtn.addEventListener('click', ()=>{
  const upcoming = toInt(upcomingEl.value);
  const willAttend = Math.min(toInt(willAttendEl.value), upcoming);
  totalEl.value = toInt(totalEl.value) + upcoming;
  attendedEl.value = toInt(attendedEl.value) + willAttend;
  prevAttended = toInt(attendedEl.value);
  upcomingEl.value = ''; willAttendEl.value = '';
  update();
  maybeRoastOnClick();
});
resetBtn.addEventListener('click', ()=>{
  if(confirm('Reset attendance data?')){
    totalEl.value = 0; attendedEl.value = 0; upcomingEl.value = ''; willAttendEl.value = '';
    setTarget(75);
    localStorage.removeItem(KEY);
    prevAttended = 0; prevWillAttend = 0;
    update(true);
  }
});

// keyboard convenience
[totalEl, attendedEl, upcomingEl, willAttendEl].forEach(inp=>{
  inp.addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){ inp.blur(); update(); }
  });
});

// initial load and periodic roast schedule
(function init(){
  if(!targets.some(t=>t.classList.contains('active'))) setTarget(75);
  loadState();
  update(true);
  // start periodic roasts if enabled
  if(roastsEnabled) schedulePeriodicRoast();
})();

</script>
</body>
</html>