<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Attendance — Roasts on Invalid Only</title>
<style>
  :root{
    --bg:#ffffff;
    --card:#ffffff;
    --muted:#6b7280;
    --text:#0b1220;
    --accent:#0ea5e9;
    --good:#10b981;
    --bad:#ef4444;
    --radius:12px;
    --hit:48px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:var(--bg); color:var(--text); -webkit-text-size-adjust:100%;}
  body{display:flex;align-items:flex-start;justify-content:center;padding:14px 12px;gap:12px;}

  .wrap{width:100%;max-width:980px;background:var(--card);border-radius:14px;padding:12px;box-shadow:0 8px 24px rgba(2,6,23,0.06); border:1px solid rgba(2,6,23,0.04); display:flex;flex-direction:column;gap:12px}
  .head{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .title{font-weight:800;font-size:18px}
  .subtitle{font-size:12px;color:var(--muted)}
  .targets{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .target{padding:10px 12px;border-radius:999px;border:1px solid rgba(2,6,23,0.06);background:transparent;font-weight:800;font-size:14px;min-height:var(--hit); display:inline-flex;align-items:center;justify-content:center; cursor:pointer;}
  .target.active{background:var(--accent);color:white;border:0; box-shadow:0 8px 20px rgba(14,165,233,0.12)}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  .label{font-size:13px;color:var(--muted);margin-bottom:6px}
  .input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(2,6,23,0.06);font-size:16px;background:transparent;-webkit-appearance:none;appearance:none;}
  .row{display:flex;gap:8px}
  .btn{flex:1;padding:12px;border-radius:12px;border:0;font-weight:900;font-size:15px;cursor:pointer;min-height:var(--hit)}
  .btn.primary{background:var(--accent);color:#fff}
  .btn.ghost{background:transparent;border:1px solid rgba(2,6,23,0.06);color:var(--muted)}
  .display{padding:12px;border-radius:12px;background:rgba(2,6,23,0.02);display:flex;flex-direction:column;gap:12px}
  .top{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .percent{font-weight:900;font-size:32px}
  .status{padding:6px 10px;border-radius:999px;font-weight:800;font-size:13px}
  .status.ok{background:rgba(16,185,129,0.12);color:var(--good)}
  .status.low{background:rgba(239,68,68,0.12);color:var(--bad)}
  .muted{color:var(--muted);font-size:13px}
  .panel-row{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .bunk{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:rgba(2,6,23,0.02);font-weight:800}
  .message{padding:10px;border-radius:10px;background:rgba(14,165,233,0.04);font-weight:700;text-align:center}

  /* roast popup (simple centered modal) */
  .roast{
    position:fixed; left:50%; top:14%; transform:translateX(-50%); min-width:320px; max-width:820px; padding:14px 16px;
    border-radius:12px; background:#111; color:#ffdede; font-weight:900; z-index:3000; display:none; box-shadow:0 20px 70px rgba(0,0,0,0.5);
  }
  .roast .txt{font-size:16px;line-height:1.25}
  .roast .close{margin-top:10px;padding:8px 10px;border-radius:10px;border:0;background:#ff3b30;color:white;cursor:pointer;font-weight:800}

  @media(min-width:760px){ .wrap{flex-direction:row} .left{width:360px;flex-shrink:0} .main{flex:1} .grid{grid-template-columns:1fr 1fr; gap:10px} .targets{flex-direction:column} }
</style>
</head>
<body>
  <main class="wrap" role="application" aria-label="Attendance — roasts on invalid">
    <div class="head">
      <div>
        <div class="title">Attendance</div>
        <div class="subtitle">White theme — roasts only on invalid</div>
      </div>
      <div class="muted">Autosave</div>
    </div>

    <section class="left" style="display:flex;flex-direction:column;gap:10px">
      <div class="muted" style="font-weight:700">Targets</div>
      <div class="targets" id="targets">
        <button class="target" data-val="75" aria-pressed="false">75%</button>
        <button class="target" data-val="80" aria-pressed="false">80%</button>
        <button class="target" data-val="85" aria-pressed="false">85%</button>
        <button class="target" data-val="90" aria-pressed="false">90%</button>
      </div>

      <div style="margin-top:4px">
        <div class="label">Total</div>
        <input id="total" class="input" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="60" />
      </div>

      <div>
        <div class="label">Attended</div>
        <input id="attended" class="input" type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="45" />
      </div>

      <div class="row" style="margin-top:6px">
        <button id="present" class="btn primary" aria-label="Mark present">+ Present</button>
        <button id="absent" class="btn ghost" aria-label="Mark absent">+ Absent</button>
      </div>

      <div style="display:flex;gap:8px;margin-top:6px">
        <input id="upcoming" class="input" type="number" inputmode="numeric" placeholder="Upcoming" />
        <input id="willAttend" class="input" type="number" inputmode="numeric" placeholder="Will attend" />
      </div>

      <div class="row" style="margin-top:6px">
        <button id="apply" class="btn ghost">Apply</button>
        <button id="reset" class="btn ghost">Reset</button>
      </div>
    </section>

    <section class="main" style="display:flex;flex-direction:column;gap:10px">
      <div class="display" aria-live="polite">
        <div class="top">
          <div>
            <div class="percent" id="percent">0.00%</div>
            <div class="muted" id="sub">Current</div>
          </div>
          <div id="statusWrap"><span class="status">—</span></div>
        </div>

        <div class="panel-row" style="margin-top:6px">
          <div class="panel-small">
            <div class="muted">Projected</div>
            <div id="proj" style="font-weight:800">0 / 0 — 0.00%</div>
          </div>
          <div class="panel-small">
            <div class="muted">Needed</div>
            <div id="needed" style="font-weight:800">—</div>
          </div>
        </div>

        <div class="bunk" style="margin-top:8px">
          <div class="muted" id="bunkLabel">You can bunk</div>
          <div id="bunkCount" style="font-weight:800">—</div>
        </div>

        <div class="message" id="message" style="margin-top:8px">—</div>
      </div>

      <footer>
        <div class="muted">Simple</div>
        <div class="muted" id="currentTarget">75%</div>
      </footer>
    </section>
  </main>

  <!-- roast popup -->
  <div id="roast" class="roast" role="alert" aria-hidden="true">
    <div class="txt" id="roastText">You can't do that idiot. WTF are you doing?</div>
    <button id="roastClose" class="close">Close</button>
  </div>

<script>
/* Roasts-on-invalid-only attendance app
   - 500 roast messages generated via templates (lightweight)
   - Roasts are shown ONLY when user attempts Attended > Total (typed or pasted)
   - No random roasts, no periodic, no other triggers
   - Mobile-friendly, white theme
*/

// helpers & DOM
const $ = id => document.getElementById(id);
const totalEl = $('total'), attendedEl = $('attended'), upcomingEl = $('upcoming'), willAttendEl = $('willAttend');
const presentBtn = $('present'), absentBtn = $('absent'), applyBtn = $('apply'), resetBtn = $('reset');
const percentEl = $('percent'), statusWrap = $('statusWrap'), projEl = $('proj'), neededEl = $('needed');
const bunkLabel = $('bunkLabel'), bunkCount = $('bunkCount'), messageEl = $('message'), currentTargetEl = $('currentTarget');
const targets = Array.from(document.querySelectorAll('.target'));
const roastBox = $('roast'), roastText = $('roastText'), roastClose = $('roastClose');

const KEY = 'att_roast_invalid_v1';
function toInt(v){ const n = parseInt(String(v).replace(/[^\d-]/g,''),10); return isNaN(n) ? 0 : Math.max(0,n); }
function pct(att, tot){ return tot <= 0 ? 0 : (att / tot) * 100; }
function classesNeeded(att, tot, targetPct){
  const t = targetPct/100;
  if(pct(att,tot) >= targetPct) return 0;
  if(t >= 1) return Infinity;
  const numerator = t * tot - att;
  const denom = 1 - t;
  return Math.max(0, Math.ceil(numerator / denom));
}
function maxBunk(att, tot, targetPct){
  const t = targetPct/100;
  if(t === 0) return Infinity;
  if(pct(att,tot) < targetPct) return 0;
  const raw = (att - t*tot)/t;
  return Math.max(0, Math.floor(raw));
}

// targets
function setTarget(v){
  targets.forEach(t => {
    const active = Number(t.dataset.val) === Number(v);
    t.classList.toggle('active', active);
    t.setAttribute('aria-pressed', active ? 'true' : 'false');
  });
  currentTargetEl.textContent = Number(v) + '%';
  update(true);
}
function getTarget(){ const a = targets.find(t => t.classList.contains('active')); return a ? Number(a.dataset.val) : 75; }
targets.forEach(t => t.addEventListener('click', ()=> setTarget(t.dataset.val)));

// build 500 roast messages lazily (templates combined)
let ROAST_POOL = null;
function buildRoastPool(n){
  if(ROAST_POOL && ROAST_POOL.length >= n) return ROAST_POOL;
  const starts = ["You can't do that", "You can't be serious", "What the fuck are you doing", "Sir, stop", "Stop right now", "Who told you to do that", "Are you for real", "You absolute idiot"];
  const middles = [
    "you can't enter more presents than total.",
    "you can't set attended higher than total.",
    "that's not how this works.",
    "this makes no sense at all.",
    "you're breaking logic here.",
    "you're trying nonsense inputs.",
    "you're being dumb with numbers."
  ];
  const jabs = [
    "You look like a fucking crazy person.",
    "You can't do that idiot.",
    "WTF are you doing?",
    "Bro, stop acting dumb.",
    "This is nonsense, fix it.",
    "You're trying to cheat reality, stop.",
    "Seriously, what are you thinking?"
  ];
  ROAST_POOL = [];
  const used = new Set();
  let attempts = 0;
  while(ROAST_POOL.length < n && attempts < n * 12){
    const a = starts[Math.floor(Math.random()*starts.length)];
    const b = middles[Math.floor(Math.random()*middles.length)];
    const c = jabs[Math.floor(Math.random()*jabs.length)];
    // combine variations and sometimes add punctuation
    let msg = `${a} — ${b} ${Math.random()<0.5 ? c : ''}`.trim();
    msg = msg.replace(/\s+/g,' ').replace(/\s+—\s+$/,'').trim();
    if(Math.random() < 0.25) msg = msg.replace(/\.$/,'') + (Math.random()<0.5 ? '!' : '...');
    if(msg.length > 6 && !used.has(msg)){
      used.add(msg);
      ROAST_POOL.push(msg);
    }
    attempts++;
  }
  // fallback fill
  while(ROAST_POOL.length < n){
    ROAST_POOL.push(`You can't do that idiot. Stop it. (${ROAST_POOL.length+1})`);
  }
  return ROAST_POOL;
}
function pickRoast(){
  buildRoastPool(500);
  return ROAST_POOL[Math.floor(Math.random()*ROAST_POOL.length)];
}

// roast UI
let roastTimer = null;
function showRoast(msg){
  roastText.textContent = msg || pickRoast();
  roastBox.style.display = 'block';
  roastBox.setAttribute('aria-hidden','false');
  if(roastTimer) clearTimeout(roastTimer);
  roastTimer = setTimeout(()=>{ roastBox.style.display = 'none'; roastBox.setAttribute('aria-hidden','true'); }, 4200);
}
roastClose.addEventListener('click', ()=>{ roastBox.style.display = 'none'; roastBox.setAttribute('aria-hidden','true'); });

// persistence
function saveState(){
  try{
    localStorage.setItem(KEY, JSON.stringify({
      total: toInt(totalEl.value),
      attended: toInt(attendedEl.value),
      upcoming: toInt(upcomingEl.value),
      willAttend: toInt(willAttendEl.value),
      target: getTarget()
    }));
  }catch(e){}
}
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(KEY) || '{}');
    if(typeof s.total === 'number') totalEl.value = s.total;
    if(typeof s.attended === 'number') attendedEl.value = s.attended;
    if(typeof s.upcoming === 'number') upcomingEl.value = s.upcoming;
    if(typeof s.willAttend === 'number') willAttendEl.value = s.willAttend;
    if(typeof s.target === 'number') setTarget(s.target);
  }catch(e){}
}

// previous valid values for revert
let prevAttended = toInt(attendedEl.value);
let prevWillAttend = toInt(willAttendEl.value);

// update (minimal)
let lastState = {};
function update(force){
  const total = toInt(totalEl.value);
  let attended = toInt(attendedEl.value);
  const upcoming = toInt(upcomingEl.value);
  let willAttend = toInt(willAttendEl.value);
  const target = getTarget();

  // If user tries to set attended > total -> revert and show roast (ONLY here)
  if(attended > total){
    attendedEl.value = prevAttended;
    attended = prevAttended;
    showRoast(pickRoast());
  } else {
    prevAttended = attended;
  }

  // willAttend revert (no roast here, only the attended>total case triggers roast per your request)
  if(willAttend > upcoming){
    willAttendEl.value = prevWillAttend;
    willAttend = prevWillAttend;
  } else {
    prevWillAttend = willAttend;
  }

  const safeAtt = Math.min(attended, total);
  const curPct = +(pct(safeAtt, total).toFixed(2));
  const state = { total, safeAtt, upcoming, willAttend, curPct, target };
  if(!force && JSON.stringify(state) === JSON.stringify(lastState)) return;
  lastState = state;

  // DOM updates
  percentEl.textContent = curPct.toFixed(2) + '%';
  if(total === 0) statusWrap.innerHTML = `<span class="status">—</span>`;
  else if(curPct >= target) statusWrap.innerHTML = `<span class="status ok">ON</span>`;
  else statusWrap.innerHTML = `<span class="status low">LOW</span>`;

  const pTot = total + upcoming;
  const pAtt = safeAtt + willAttend;
  projEl.textContent = `${pAtt} / ${pTot} — ${ (pTot===0) ? '0.00%' : pct(pAtt,pTot).toFixed(2)+'%' }`;

  const needed = classesNeeded(attended, total, target);
  neededEl.textContent = needed === Infinity ? 'Impossible' : (needed + (needed===1 ? ' class' : ' classes'));

  if(total === 0 && attended === 0){
    bunkLabel.textContent = 'You can bunk'; bunkCount.textContent = '—'; messageEl.textContent='Enter values';
  } else if(curPct >= target){
    const bunk = maxBunk(attended, total, target);
    bunkLabel.textContent = 'You can bunk'; bunkCount.textContent = (bunk === Infinity) ? 'Many' : (bunk + (bunk===1 ? ' class' : ' classes'));
    messageEl.textContent = bunk > 0 ? `You can skip ${bunk} and still meet ${target}%.` : 'On track — keep it up.';
  } else {
    const needCount = needed === Infinity ? 'Impossible' : (needed + (needed===1 ? ' class' : ' classes'));
    bunkLabel.textContent = 'You need'; bunkCount.textContent = needCount; messageEl.textContent = 'Below target — attend more.';
  }

  saveState();
}

// wire inputs: show roast only when attended > total attempt (already handled in update)
attendedEl.addEventListener('focus', ()=> prevAttended = toInt(attendedEl.value));
attendedEl.addEventListener('input', ()=>{ update(); });

willAttendEl.addEventListener('focus', ()=> prevWillAttend = toInt(willAttendEl.value));
willAttendEl.addEventListener('input', ()=>{
  const entered = toInt(willAttendEl.value), upcoming = toInt(upcomingEl.value);
  if(entered > upcoming){ willAttendEl.value = prevWillAttend; } else { prevWillAttend = entered; update(); }
});

totalEl.addEventListener('input', ()=>{
  const total = toInt(totalEl.value), attended = toInt(attendedEl.value);
  if(attended > total){
    // If total reduced below attended, cap attended to total (this is a non-roast event)
    attendedEl.value = total;
    prevAttended = total;
  }
  update();
});
upcomingEl.addEventListener('input', update);

// buttons
presentBtn.addEventListener('click', ()=>{
  // present increments both total & attended (keeps attended <= total) so won't trigger roast
  totalEl.value = toInt(totalEl.value) + 1;
  attendedEl.value = toInt(attendedEl.value) + 1;
  prevAttended = toInt(attendedEl.value);
  update();
});
absentBtn.addEventListener('click', ()=>{
  totalEl.value = toInt(totalEl.value) + 1;
  update();
});
applyBtn.addEventListener('click', ()=>{
  const upcoming = toInt(upcomingEl.value);
  const willAttend = Math.min(toInt(willAttendEl.value), upcoming);
  totalEl.value = toInt(totalEl.value) + upcoming;
  attendedEl.value = toInt(attendedEl.value) + willAttend;
  prevAttended = toInt(attendedEl.value);
  upcomingEl.value = ''; willAttendEl.value = '';
  update();
});
resetBtn.addEventListener('click', ()=>{
  if(confirm('Reset attendance data?')){
    totalEl.value = 0; attendedEl.value = 0; upcomingEl.value = ''; willAttendEl.value = '';
    setTarget(75);
    localStorage.removeItem(KEY);
    prevAttended = 0; prevWillAttend = 0;
    update(true);
  }
});

// keyboard convenience
[totalEl, attendedEl, upcomingEl, willAttendEl].forEach(inp=>{
  inp.addEventListener('keydown', (e) => {
    if(e.key === 'Enter'){ inp.blur(); update(); }
  });
});

// init
function classesNeeded(att, tot, targetPct){
  const t = targetPct/100;
  if(pct(att,tot) >= targetPct) return 0;
  if(t >= 1) return Infinity;
  const numerator = t * tot - att;
  const denom = 1 - t;
  return Math.max(0, Math.ceil(numerator / denom));
}
function maxBunk(att, tot, targetPct){
  const t = targetPct/100;
  if(t === 0) return Infinity;
  if(pct(att,tot) < targetPct) return 0;
  const raw = (att - t*tot)/t;
  return Math.max(0, Math.floor(raw));
}

function loadAndStart(){
  loadState();
  if(!targets.some(t=>t.classList.contains('active'))) setTarget(75);
  update(true);
}
loadAndStart();

</script>
</body>
</html>